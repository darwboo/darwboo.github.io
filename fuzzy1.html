<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-File Data Matcher</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #1e1e1e;
            color: #f0f0f0;
            margin: 20px;
            line-height: 1.6; /* Improved readability */
        }
        .light-theme {
            background-color: #f9f5f3; /* Soft off-white */
            color: #555; /* Medium gray for text */
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .file-upload-section, .column-selection-section, .output-section, .download-section, .instructions-section {
            border: 1px solid #444;
            padding: 15px;
            border-radius: 5px;
            background-color: #2a2a2a; /* Slightly darker for dark theme sections */
        }
        .light-theme .file-upload-section, .light-theme .column-selection-section, .light-theme .output-section, .light-theme .download-section, .light-theme .instructions-section {
            border-color: #ddd; /* Light gray border */
            background-color: #fff; /* White background for light theme sections */
        }
        .file-upload-inputs {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center; /* Align label and input vertically */
        }
         .file-info { /* New style for file info */
             font-size: small;
             color: #aaa;
             margin-left: 10px;
         }
         .light-theme .file-info {
             color: #777;
         }
        .column-selection-boxes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 10px;
        }
        .column-selection-box label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .column-checkboxes {
            display: flex;
            flex-direction: column;
            border: 1px solid #666;
            padding: 10px;
            border-radius: 3px;
            background-color: #333;
        }
        .light-theme .column-checkboxes {
            border-color: #eee; /* Very light gray border */
            background-color: #f4f4f4; /* Light gray background */
        }
        .column-checkboxes label {
            font-weight: normal;
        }
        #output-container {
            border: 1px solid #555;
            border-radius: 5px;
            padding: 10px;
            background-color: #222;
            position: relative;
        }
        .light-theme #output-container {
            border-color: #ccc; /* Light gray border */
            background-color: #f9f9f9; /* Very light gray background */
        }
        #output-table-container-top, #output-table-container-bottom {
            overflow: auto; /* Changed to auto to enable both scroll directions */
            max-height: 400px; /* Increased for better viewability */
            margin-bottom: 5px;
            position: relative; /* Needed for sticky positioning of children */
        }
        #output-table {
            width: 100%;
            border-collapse: collapse;
        }
        #output-table th, #output-table td {
            border: 1px solid #666;
            padding: 8px;
            text-align: left;
        }
        .light-theme #output-table th, .light-theme #output-table td {
            border-color: #e0e0e0; /* Lighter gray table borders */
        }
        #output-table thead th {
            position: sticky;
            top: 0;
            background-color: #333; /* Or inherit if you prefer */
            z-index: 1;
        }
        .light-theme #output-table thead th {
            background-color: #e9ecef; /* Light gray header background */
            color: #555; /* Darker text for header */
        }
        #output-table tbody td:first-child {
            position: sticky;
            left: 0;
            background-color: #222; /* Or inherit */
            z-index: 2; /* Higher than header to be on top if needed */
        }
        .light-theme #output-table tbody td:first-child {
            background-color: #f9f9f9; /* Very light gray row number background */
            color: #555;
        }
         .fuzzy-match-cell {
             font-style: italic;
             color: #bbb; /* Muted color for fuzzy details */
         }
         .light-theme .fuzzy-match-cell {
             color: #777; /* Muted color for fuzzy details in light theme */
         }
        /* Updated Accessible Colors */
        .file1-cell { background-color: #004f9f; color: #ffffff; } /* More accessible blue */
        .file2-cell { background-color: #38761d; color: #ffffff; } /* More accessible green */
        .file3-cell { background-color: #e69138; color: #ffffff; } /* More accessible orange */
        .file4-cell { background-color: #cc0000; color: #ffffff; } /* More accessible red */

        .light-theme .file1-cell { background-color: #b3e5fc; color: #000000; } /* More accessible light blue */
        .light-theme .file2-cell { background-color: #c8e6c9; color: #000000; } /* More accessible light green */
        .light-theme .file3-cell { background-color: #ffe0b2; color: #000000; } /* More accessible light orange */
        .light-theme .file4-cell { background-color: #ffcdd2; color: #000000; } /* More accessible light red */

        .controls {
            margin-bottom: 10px;
        }
        .theme-toggle {
            margin-bottom: 10px;
        }
        .download-options label {
            display: block;
            margin-bottom: 5px;
        }
        .download-options input[type="checkbox"] {
            margin-right: 5px;
        }
        button {
            padding: 10px 20px; /* Slightly larger buttons */
            border: none;
            border-radius: 5px; /* Slightly more rounded */
            cursor: pointer;
            background-color: #555;
            color: #f0f0f0;
            margin-top: 5px; /* Add some space between buttons */
            margin-right: 10px; /* Space between buttons */
        }
        .light-theme button {
            background-color: #e0e0e0; /* Light gray button */
            color: #333; /* Darker text for button */
        }
        button:hover {
            background-color: #777;
        }
        .light-theme button:hover {
            background-color: #d0d0d0; /* Slightly darker light gray on hover */
        }
        #loading-indicator {
            display: none;
            margin-top: 10px;
            color: #aaa;
        }
        .light-theme #loading-indicator {
            color: #777; /* Medium gray for loading text */
        }
        .instructions-section ol {
            padding-left: 20px;
        }
        .instructions-section li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="theme-toggle">
            <button id="theme-button">Switch to Light Theme</button>
        </div>

        <div class="instructions-section" id="instructions">
            <h2>Usage Instructions</h2>
            <p>Multi-File Data Matcher is a straightforward web application that helps you find common rows between multiple CSV and Excel files. Upload your files, specify the columns you want to compare, and quickly see the matching records. The application features a clean and calming light theme for comfortable data processing and offers flexible download options.</p>
            <ol>
                <li><strong>File Upload:</strong> Click the "Choose File" buttons to upload up to 4 CSV or Excel files. Ensure each file has a descriptive name.</li>
                <li><strong>Column Selection:</strong> Once files are uploaded, the column names from each file will appear. Check the boxes next to the columns you want to use for matching rows. You can select up to 4 columns per file.</li>
                <li><strong>Match Rows:</strong> Use the buttons below to find matching or non-matching rows based on your selected columns.
                    <ul>
                        <li>"Match Rows (All Files)": Find rows with common data in the selected columns across *all* uploaded files.</li>
                        <li>"Find Rows with At Least One Match": Find rows from the first file that have a match in the selected columns in *any* of the other uploaded files.</li>
                        <li>"Show Non-Matching Rows (From File 1)": Display rows from the first file that do *not* have a match in the selected columns in *any* of the other uploaded files.</li>
                         <li>"Show Possible Matches (Fuzzy)": Find rows across different files where the selected matching columns have similar (possibly misspelled) data.</li>
                    </ul>
                </li>
                <li><strong>View Output:</strong> The matching/non-matching records will be displayed in the box below. Use the scroll bars above and below the table to view all rows and columns. Each file's data will have a distinct background color (for exact/any matches). Row numbers and headers will remain visible while scrolling. The bottom output will start at the end of the matched list. Fuzzy matches are displayed as a list of pairs.</li>
                <li><strong>Download Output:</strong> Optionally, use the "Select All" or "Unselect All" options to choose which columns to include in the downloaded file and click the "Download Output" button. The output will be downloaded as a CSV file.</li>
            </ol>
        </div>

        <div class="file-upload-section" aria-describedby="instructions-file-upload">
            <h2>Upload Files</h2>
            <div class="file-upload-inputs">
                <label for="file1">File 1:</label>
                <input type="file" id="file1" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                <div id="file1-info" class="file-info"></div> <!-- Placeholder for file 1 info -->
            </div>
            <div class="file-upload-inputs">
                <label for="file2">File 2:</label>
                <input type="file" id="file2" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                 <div id="file2-info" class="file-info"></div> <!-- Placeholder for file 2 info -->
            </div>
            <div class="file-upload-inputs">
                <label for="file3">File 3:</label>
                <input type="file" id="file3" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                 <div id="file3-info" class="file-info"></div> <!-- Placeholder for file 3 info -->
            </div>
            <div class="file-upload-inputs">
                <label for="file4">File 4:</label>
                <input type="file" id="file4" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                 <div id="file4-info" class="file-info"></div> <!-- Placeholder for file 4 info -->
            </div>
            <p id="instructions-file-upload" style="font-size: small; color: #888;">Select up to 4 files in CSV or Excel format.</p>
        </div>

        <div class="column-selection-section" aria-describedby="instructions-column-selection">
            <h2>Select Matching Columns</h2>
            <div class="column-selection-boxes" id="column-selection-boxes">
                <!-- Column selection boxes will be generated here -->
            </div>
            <button onclick="matchRows()">Match Rows (All Files)</button>
            <button onclick="findAnyMatchingRows()">Find Rows with At Least One Match</button>
             <button onclick="findNonMatchingRows()">Show Non-Matching Rows (From File 1)</button>
             <button id="show-fuzzy-matches-button">Show Possible Matches (Fuzzy)</button>
            <p id="loading-indicator">Processing rows...</p>
            <p id="instructions-column-selection" style="font-size: small; color: #888;">Choose up to 4 columns from each uploaded file to match rows.</p>
        </div>

        <div class="output-section" aria-live="polite" aria-describedby="instructions-output">
            <h2>Matching Records</h2>
            <div id="output-container">
                <div id="output-table-container-top">
                    <!-- Top scroll bar -->
                </div>
                <div id="output-table-container-bottom">
                    <table id="output-table">
                        <thead>
                            <tr><th>#</th></tr>
                        </thead>
                        <tbody>
                            <!-- Matching records will be displayed here -->
                        </tbody>
                    </table>
                </div>
            </div>
            <p id="instructions-output" style="font-size: small; color: #888;">The matching/non-matching records are displayed below. Use the scrollbars to view all data.</p>
        </div>

        <div class="download-section" aria-describedby="instructions-download">
            <h2>Download Output</h2>
            <div class="download-options" id="download-options">
                <label>Select columns to include in download:</label><br>
                <input type="checkbox" id="select-all-columns" onchange="selectAllDownloadColumns(this.checked)">
                <label for="select-all-columns">Select All</label><br>
                <input type="checkbox" id="unselect-all-columns" onchange="unselectAllDownloadColumns(this.checked)">
                <label for="unselect-all-columns">Unselect All</label><br>
                <!-- Download column options will be generated here -->
            </div>
            <button onclick="downloadOutput()">Download Output</button>
            <p id="instructions-download" style="font-size: small; color: #888;">Choose columns to include in the downloaded CSV file.</p>
        </div>
    </div>

    <script>
        const fileInputs = [
            document.getElementById('file1'),
            document.getElementById('file2'),
            document.getElementById('file3'),
            document.getElementById('file4')
        ];
        const columnSelectionBoxes = document.getElementById('column-selection-boxes');
        const outputTableContainerTop = document.getElementById('output-table-container-top');
        const outputTableContainerBottom = document.getElementById('output-table-container-bottom');
        const outputTableBody = document.querySelector('#output-table tbody');
        const downloadOptionsDiv = document.getElementById('download-options');
        const loadingIndicator = document.getElementById('loading-indicator');
        const themeButton = document.getElementById('theme-button');
        const body = document.body;
         const showFuzzyMatchesButton = document.getElementById('show-fuzzy-matches-button');

        let filesData = [];
        let allColumnHeaders = [];
        let currentTheme = 'dark';

        themeButton.addEventListener('click', () => {
            body.classList.toggle('light-theme');
            currentTheme = body.classList.contains('light-theme') ? 'light' : 'dark';
            themeButton.textContent = currentTheme === 'dark' ? 'Switch to Light Theme' : 'Switch to Dark Theme';
        });

        fileInputs.forEach((input, index) => {
            input.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    readFile(file, index + 1);
                } else {
                    filesData[index] = null;
                    updateColumnSelection(); // Call update to clear info and columns
                }
            });
        });

        function readFile(file, fileNumber) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const contents = event.target.result;
                const lines = contents.split('\n').map(line => line.trim());
                if (lines.length > 0) {
                    const headers = lines[0].split(',').map(header => header.trim());
                    const data = lines.slice(1).map(line => line.split(',').map(cell => cell.trim()));
                    filesData[fileNumber - 1] = { name: file.name, headers: headers, data: data };
                } else {
                    filesData[fileNumber - 1] = null;
                }
                updateColumnSelection();
            };
            reader.onerror = () => {
                alert(`Error reading file ${file.name}`);
                filesData[fileNumber - 1] = null;
                updateColumnSelection(); // Call update to clear info and columns
            };
            reader.readAsText(file);
        }

        function updateColumnSelection() {
            columnSelectionBoxes.innerHTML = '';
            allColumnHeaders = [];
            // Clear previous file info
            for(let i = 1; i <= 4; i++) {
                const fileInfoDiv = document.getElementById(`file${i}-info`);
                if(fileInfoDiv) {
                    fileInfoDiv.textContent = '';
                }
            }

            filesData.forEach((fileData, index) => {
                const fileNumber = index + 1;
                const fileInfoDiv = document.getElementById(`file${fileNumber}-info`);
                if (fileData && fileData.headers) {
                    // Display row and column counts
                    if(fileInfoDiv) {
                         fileInfoDiv.textContent = `Rows: ${fileData.data.length}, Columns: ${fileData.headers.length}`;
                     }


                    const box = document.createElement('div');
                    box.classList.add('column-selection-box');
                    box.innerHTML = `<label>File ${fileNumber}: ${fileData.name}</label><div class="column-checkboxes" id="file${fileNumber}-columns"></div>`;
                    columnSelectionBoxes.appendChild(box);
                    const checkboxesDiv = box.querySelector(`#file${fileNumber}-columns`);
                    fileData.headers.forEach(header => {
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `file${fileNumber}-${header.replace(/[^a-zA-Z0-9]/g, '')}`;
                        checkbox.value = header;
                        const label = document.createElement('label');
                        label.setAttribute('for', `file${fileNumber}-${header.replace(/[^a-zA-Z0-9]/g, '')}`);
                        label.textContent = header;
                        checkboxesDiv.appendChild(checkbox);
                        checkboxesDiv.appendChild(label);
                        checkboxesDiv.appendChild(document.createElement('br'));
                        if (!allColumnHeaders.includes(header)) {
                            allColumnHeaders.push(header);
                        }
                    });
                }
            });
            updateDownloadOptions();
        }

        function getSelectedColumns() {
            const selectedColumns = [];
            filesData.forEach((fileData, index) => {
                if (fileData) {
                    const fileNumber = index + 1;
                    const selected = [];
                    const checkboxes = document.querySelectorAll(`#file${fileNumber}-columns input[type="checkbox"]:checked`);
                    checkboxes.forEach(checkbox => {
                        selected.push(checkbox.value);
                    });
                    selectedColumns.push(selected);
                } else {
                    selectedColumns.push([]);
                }
            });
            return selectedColumns;
        }

        function matchRows() {
            if (!filesData.some(data => data !== null)) {
                alert('Please upload at least one file.');
                return;
            }

            const selectedColumns = getSelectedColumns();
            if (selectedColumns.some(cols => cols.length > 4)) {
                alert('You can select a maximum of 4 columns per file for matching.');
                return;
            }

            loadingIndicator.style.display = 'block';
            setTimeout(() => {
                const matchedRows = findMatchingRows(filesData, selectedColumns);
                displayMatchingRows(matchedRows);
                loadingIndicator.style.display = 'none';
            }, 100); // Simulate processing time
        }

        function findMatchingRows(data, selectedColumns) {
            if (data.every(file => file === null)) {
                return [];
            }

            const validFilesData = data.filter(file => file !== null);
            const validSelectedColumns = selectedColumns.filter((_, index) => data[index] !== null);

            if (validFilesData.length <= 1) {
                // If only one or zero files are uploaded, consider all rows as "matching" with themselves
                if (validFilesData.length === 1) {
                    return validFilesData[0].data.map((_, index) => {
                        const record = {};
                        validFilesData[0].headers.forEach((header, headerIndex) => {
                            record[`File1 - ${header}`] = validFilesData[0].data[index][headerIndex];
                        });
                        return record;
                    });
                }
                return [];
            }

            const matchedRecords = [];
            const firstFileData = validFilesData[0];
            const firstSelectedColumns = validSelectedColumns[0];

            firstFileData.data.forEach((row, rowIndex) => {
                const matchKey = firstSelectedColumns.map(col => row[firstFileData.headers.indexOf(col)]).join('|||');
                let isMatchInAll = true;
                const currentRowIndices = { 0: rowIndex };

                for (let i = 1; i < validFilesData.length; i++) {
                    const currentFileData = validFilesData[i];
                    const currentSelectedColumns = validSelectedColumns[i];
                    let foundMatchInCurrentFile = false;
                    currentFileData.data.forEach((currentRow, currentRowIndex) => {
                        const currentRowMatchKey = currentSelectedColumns.map(col => currentRow[currentFileData.headers.indexOf(col)]).join('|||');
                        if (matchKey === currentRowMatchKey) {
                            currentRowIndices[i] = currentRowIndex;
                            foundMatchInCurrentFile = true;
                            return; // Found a match in this file, move to the next file
                        }
                    });
                    if (!foundMatchInCurrentFile) {
                        isMatchInAll = false;
                        return; // No match found in this file, no need to check further files for this first file row
                    }
                }

                if (isMatchInAll) {
                    const record = {};
                    Object.keys(currentRowIndices).forEach(fileIndexStr => {
                        const fileIndex = parseInt(fileIndexStr);
                        const rowIndex = currentRowIndices[fileIndex];
                        const fileData = validFilesData[fileIndex];
                        fileData.headers.forEach((header, headerIndex) => {
                            record[`File${fileIndex + 1} - ${header}`] = fileData.data[rowIndex][headerIndex];
                        });
                    });
                    matchedRecords.push(record);
                }
            });

            return matchedRecords;
        }

        function findAnyMatchingRows() {
            if (!filesData.some(data => data !== null)) {
                alert('Please upload at least one file.');
                return;
            }

            const selectedColumns = getSelectedColumns();
            if (selectedColumns.some(cols => cols.length > 4)) {
                alert('You can select a maximum of 4 columns per file for matching.');
                return;
            }

            loadingIndicator.style.display = 'block';
            setTimeout(() => {
                const matchedRows = findRowsWithAnyMatch(filesData, selectedColumns);
                displayMatchingRows(matchedRows);
                loadingIndicator.style.display = 'none';
            }, 100); // Simulate processing time
        }

        function findRowsWithAnyMatch(data, selectedColumns) {
            if (data.every(file => file === null)) {
                return [];
            }

            const validFilesData = data.filter(file => file !== null);
            const validSelectedColumns = selectedColumns.filter((_, index) => data[index] !== null);

            if (validFilesData.length <= 1) {
                 if (validFilesData.length === 1) {
                    // If only one file, all rows are "matches" with themselves in this context
                    return validFilesData[0].data.map((_, index) => {
                        const record = {};
                        validFilesData[0].headers.forEach((header, headerIndex) => {
                             record[`File1 - ${header}`] = validFilesData[0].data[index][headerIndex];
                        });
                        return record;
                    });
                }
                return [];
            }

            const matchedRecords = [];
             const processedFirstFileRows = new Set(); // To avoid processing the same first file row multiple times

            const firstFileData = validFilesData[0];
            const firstSelectedColumns = validSelectedColumns[0];

             // Iterate through each row of the first file
            firstFileData.data.forEach((row, rowIndex) => {
                 if (processedFirstFileRows.has(rowIndex)) return; // Skip if already processed

                const matchKey = firstSelectedColumns.map(col => row[firstFileData.headers.indexOf(col)]).join('|||');
                let hasMatchInAnyOther = false;
                 const currentRowIndices = { 0: rowIndex }; // Store indices for the first file row

                for (let i = 1; i < validFilesData.length; i++) {
                    const currentFileData = validFilesData[i];
                    const currentSelectedColumns = validSelectedColumns[i];

                    currentFileData.data.forEach((currentRow, currentRowIndex) => {
                        const currentRowMatchKey = currentSelectedColumns.map(col => currentRow[currentFileData.headers.indexOf(col)]).join('|||');
                        if (matchKey === currentRowMatchKey) {
                            hasMatchInAnyOther = true;
                             currentRowIndices[i] = currentRowIndex; // Store matching index for this file
                        }
                    });
                }

                if (hasMatchInAnyOther) {
                    const record = {};
                    // Include data from all files that had a match for this row from the first file
                    for (let j = 0; j < validFilesData.length; j++) {
                         const fileDataToInclude = validFilesData[j];
                         const rowIndexToInclude = currentRowIndices[j]; // Use stored index

                         if (rowIndexToInclude !== undefined && fileDataToInclude && fileDataToInclude.data[rowIndexToInclude]) {
                             fileDataToInclude.headers.forEach((header, headerIndex) => {
                                 record[`File${j + 1} - ${header}`] = fileDataToInclude.data[rowIndexToInclude][headerIndex];
                             });
                         } else if (j === 0 && rowIndexToInclude !== undefined && fileDataToInclude && fileDataToInclude.data[rowIndexToInclude]) {
                             // Always include the row from the first file if it was processed
                              fileDataToInclude.headers.forEach((header, headerIndex) => {
                                 record[`File${j + 1} - ${header}`] = fileDataToInclude.data[rowIndexToInclude][headerIndex];
                             });
                         } else {
                             // Include empty cells for files that didn't have a match for this key
                             if (validFilesData[j]) { // Check if the file exists
                                 validFilesData[j].headers.forEach(header => {
                                     record[`File${j + 1} - ${header}`] = '';
                                 });
                             }
                         }
                    }
                    matchedRecords.push(record);
                     processedFirstFileRows.add(rowIndex); // Mark this row from the first file as processed
                }
            });

             // Now, find rows in other files that didn't match anything in the first file
             for (let i = 1; i < validFilesData.length; i++) {
                const currentFileData = validFilesData[i];
                const currentSelectedColumns = validSelectedColumns[i];
                const firstSelectedColumns = validSelectedColumns[0]; // Selected columns from the first file

                currentFileData.data.forEach((row, rowIndex) => {
                    const matchKey = currentSelectedColumns.map(col => row[currentFileData.headers.indexOf(col)]).join('|||');
                    let hasMatchInFirst = false;

                    if (firstFileData) {
                        firstFileData.data.forEach(firstRow => {
                            const firstRowMatchKey = firstSelectedColumns.map(col => firstRow[firstFileData.headers.indexOf(col)]).join('|||');
                            if (matchKey === firstRowMatchKey) {
                                hasMatchInFirst = true;
                            }
                        });
                    }

                    if (!hasMatchInFirst) {
                         // Check if this row from the current file has a match in any other file (excluding the first)
                         let hasMatchInAnyOtherBesidesFirst = false;
                         for (let j = 1; j < validFilesData.length; j++) {
                             if (i === j) continue; // Don't compare a file to itself
                             const otherFileData = validFilesData[j];
                             const otherSelectedColumns = validSelectedColumns[j];
                             otherFileData.data.forEach(otherRow => {
                                 const otherRowMatchKey = otherSelectedColumns.map(col => otherRow[otherSelectedColumns.indexOf(col)]).join('|||');
                                 if (matchKey === otherRowMatchKey) {
                                     hasMatchInAnyOtherBesidesFirst = true;
                                 }
                             });
                             if (hasMatchInAnyOtherBesidesFirst) break;
                         }

                         if (hasMatchInAnyOtherBesidesFirst) {
                             const record = {};
                             // Include data from the current file and any others that match it (excluding the first)
                             for (let j = 0; j < validFilesData.length; j++) {
                                 const fileDataToInclude = validFilesData[j];
                                  let rowIndexToInclude = -1; // Placeholder for index

                                  if (j === i) {
                                       rowIndexToInclude = rowIndex; // The current row in the current file
                                  } else if (validFilesData[j]) { // Check if file exists
                                      const selectedColsToConsider = validSelectedColumns[j];
                                      validFilesData[j].data.forEach((otherRow, otherRowIndex) => {
                                          const otherRowMatchKey = selectedColsToConsider.map(col => otherRow[selectedColsToConsider.indexOf(col)]).join('|||');
                                          if (matchKey === otherRowMatchKey) {
                                               rowIndexToInclude = otherRowIndex;
                                          }
                                      });
                                  }


                                  if (rowIndexToInclude !== -1 && fileDataToInclude && fileDataToInclude.data[rowIndexToInclude]) {
                                      fileDataToInclude.headers.forEach((header, headerIndex) => {
                                          record[`File${j + 1} - ${header}`] = fileDataToInclude.data[rowIndexToInclude][headerIndex];
                                      });
                                  } else {
                                       // Include empty cells for files that didn't have a match for this key
                                       if (validFilesData[j]) { // Check if the file exists
                                           validFilesData[j].headers.forEach(header => {
                                               record[`File${j + 1} - ${header}`] = '';
                                           });
                                       }
                                  }
                              }
                             matchedRecords.push(record);
                         }
                    }
                });
             }


            return matchedRecords;
        }


         function findNonMatchingRows() {
            if (!filesData.some(data => data !== null)) {
                alert('Please upload at least one file.');
                return;
            }

            const selectedColumns = getSelectedColumns();
            if (selectedColumns.some(cols => cols.length > 4)) {
                alert('You can select a maximum of 4 columns per file for matching.');
                return;
            }

            loadingIndicator.style.display = 'block';
            setTimeout(() => {
                const nonMatchingRows = findNonMatchingRowsLogic(filesData, selectedColumns);
                displayMatchingRows(nonMatchingRows); // Reuse display function
                loadingIndicator.style.display = 'none';
            }, 100); // Simulate processing time
        }

        function findNonMatchingRowsLogic(data, selectedColumns) {
             if (data.every(file => file === null)) {
                return [];
            }

            const validFilesData = data.filter(file => file !== null);
            const validSelectedColumns = selectedColumns.filter((_, index) => data[index] !== null);

            if (validFilesData.length <= 1) {
                // If only one or zero files, all rows in the first file are non-matching (relative to other files)
                if (validFilesData.length === 1) {
                     return validFilesData[0].data.map((_, index) => {
                        const record = {};
                        validFilesData[0].headers.forEach((header, headerIndex) => {
                            record[`File1 - ${header}`] = validFilesData[0].data[index][headerIndex];
                        });
                        return record;
                    });
                }
                return [];
            }

            const nonMatchingRecords = [];
            const firstFileData = validFilesData[0];
            const firstSelectedColumns = validSelectedColumns[0];

            firstFileData.data.forEach((row, rowIndex) => {
                const matchKey = firstSelectedColumns.map(col => row[firstFileData.headers.indexOf(col)]).join('|||');
                let hasMatchInAnyOther = false;

                for (let i = 1; i < validFilesData.length; i++) {
                    const currentFileData = validFilesData[i];
                    const currentSelectedColumns = validSelectedColumns[i];

                    // Check if any row in the current file matches the key
                    if (currentFileData.data.some(currentRow => {
                         const currentRowMatchKey = currentSelectedColumns.map(col => currentRow[currentFileData.headers.indexOf(col)]).join('|||');
                         return matchKey === currentRowMatchKey;
                    })) {
                        hasMatchInAnyOther = true;
                        break; // Found a match in at least one other file, so this row is NOT non-matching
                    }
                }

                if (!hasMatchInAnyOther) {
                    // If no match was found in any other file, this row from the first file is non-matching
                    const record = {};
                    // Only include data from the first file for non-matching rows
                    if (firstFileData) {
                         firstFileData.headers.forEach((header, headerIndex) => {
                             record[`File1 - ${header}`] = firstFileData.data[rowIndex][headerIndex];
                         });
                         // Include empty cells for other files to maintain table structure
                         for(let i = 1; i < filesData.length; i++) {
                              if (filesData[i]) { // Check if the file slot is used
                                  filesData[i].headers.forEach(header => {
                                        record[`File${i + 1} - ${header}`] = '';
                                  });
                              }
                         }
                    }
                    nonMatchingRecords.push(record);
                }
            });

            return nonMatchingRecords;
        }

         // Levenshtein Distance function (a common implementation)
        function levenshteinDistance(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1[i - 1] !== s2[j - 1]) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }
            return costs[s2.length];
        }

         // Function to find fuzzy matching pairs
        function findFuzzyMatchingPairs(data, selectedColumns, threshold = 0.8) { // Added default threshold
            const fuzzyMatches = [];
            const validFilesData = data.filter(file => file !== null);
            const validSelectedColumns = selectedColumns.filter((_, index) => data[index] !== null);

            if (validFilesData.length < 2) {
                return []; // Need at least two files to find fuzzy matches between them
            }

            // Iterate through pairs of files
            for (let i = 0; i < validFilesData.length; i++) {
                for (let j = i + 1; j < validFilesData.length; j++) {
                    const file1Data = validFilesData[i];
                    const file2Data = validFilesData[j];
                    const file1SelectedCols = validSelectedColumns[i];
                    const file2SelectedCols = validSelectedColumns[j];

                    // Ensure both files have selected columns for comparison and the same number of columns
                    if (file1SelectedCols.length === 0 || file2SelectedCols.length === 0 || file1SelectedCols.length !== file2SelectedCols.length) {
                         console.warn(`Skipping fuzzy match between File ${i + 1} and File ${j + 1}: Column selection mismatch.`);
                         continue;
                    }

                    // Iterate through rows of the first file in the pair
                    file1Data.data.forEach((row1, rowIndex1) => {
                         // Iterate through rows of the second file in the pair
                        file2Data.data.forEach((row2, rowIndex2) => {
                            let allSelectedColsFuzzyMatch = true;
                            const fuzzyMatchedValues = {}; // To store which columns had fuzzy matches
                            let hasAnyNonEmptyColumnPair = false; // Flag to check for non-empty column pairs


                            // Compare values in selected columns
                            for (let k = 0; k < file1SelectedCols.length; k++) {
                                const col1Name = file1SelectedCols[k];
                                const col2Name = file2SelectedCols[k];

                                const value1 = row1[file1Data.headers.indexOf(col1Name)] || '';
                                const value2 = row2[file2Data.headers.indexOf(col2Name)] || '';

                                 // Check if at least one value in this column pair is non-empty
                                if (value1.trim() !== '' || value2.trim() !== '') {
                                    hasAnyNonEmptyColumnPair = true;
                                }


                                 let currentSimilarity;
                                 // Check if the column name suggests it might contain names (case-insensitive)
                                 const isNameColumn = /name|full name/i.test(col1Name) || /name|full name/i.test(col2Name);

                                 if (isNameColumn) {
                                     // Handle reversed names
                                     const value1Parts = value1.split(' ').filter(part => part.length > 0);
                                     const value2Parts = value2.split(' ').filter(part => part.length > 0);

                                     const value1Reversed = value1Parts.length > 1 ? value1Parts.reverse().join(' ') : value1;
                                     const value2Reversed = value2Parts.length > 1 ? value2Parts.reverse().join(' ') : value2;

                                     // Calculate similarity between original and reversed name combinations
                                     const sim1 = (Math.max(value1.length, value2.length) === 0) ? 1 : (Math.max(value1.length, value2.length) - levenshteinDistance(value1, value2)) / Math.max(value1.length, value2.length);
                                     const sim2 = (Math.max(value1.length, value2Reversed.length) === 0) ? 1 : (Math.max(value1.length, value2Reversed.length) - levenshteinDistance(value1, value2Reversed)) / Math.max(value1.length, value2Reversed.length);
                                     const sim3 = (Math.max(value1Reversed.length, value2.length) === 0) ? 1 : (Math.max(value1Reversed.length, value2.length) - levenshteinDistance(value1Reversed, value2)) / Math.max(value1Reversed.length, value2.length);
                                     const sim4 = (Math.max(value1Reversed.length, value2Reversed.length) === 0) ? 1 : (Math.max(value1Reversed.length, value2Reversed.length) - levenshteinDistance(value1Reversed, value2Reversed)) / Math.max(value1Reversed.length, value2Reversed.length);

                                     currentSimilarity = Math.max(sim1, sim2, sim3, sim4);

                                 } else {
                                     // Original similarity calculation for non-name columns
                                     const distance = levenshteinDistance(value1, value2);
                                     const maxLen = Math.max(value1.length, value2.length);
                                     currentSimilarity = maxLen === 0 ? 1 : (maxLen - distance) / maxLen;
                                 }


                                if (currentSimilarity < threshold) {
                                    allSelectedColsFuzzyMatch = false;
                                    break; // No fuzzy match for this set of columns
                                } else {
                                     fuzzyMatchedValues[`${file1Data.name} - ${col1Name}`] = value1;
                                     fuzzyMatchedValues[`${file2Data.name} - ${col2Name}`] = value2;
                                }
                            }

                            // Only add the match if all selected columns had a fuzzy match AND at least one column pair was non-empty
                            if (allSelectedColsFuzzyMatch && hasAnyNonEmptyColumnPair) {
                                fuzzyMatches.push({
                                    file1: file1Data.name,
                                    row1Index: rowIndex1 + 2, // +1 for 0-based index, +1 for header row
                                    file2: file2Data.name,
                                    row2Index: rowIndex2 + 2,
                                    matchedColumns: fuzzyMatchedValues // Store the values that matched
                                });
                            }
                        });
                    });
                }
            }

            return fuzzyMatches;
        }

        // Function to display fuzzy matches
        function displayFuzzyMatches(fuzzyMatches) {
            outputTableBody.innerHTML = ''; // Clear previous output
            const headerRow = document.querySelector('#output-table thead tr');
            while (headerRow.cells.length > 1) {
                headerRow.deleteCell(1);
            }

            if (fuzzyMatches.length === 0) {
                const row = outputTableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 2; // Row number and Match Details
                cell.textContent = 'No possible fuzzy matches found based on the selected columns and threshold.';
                 outputTableContainerTop.style.overflowX = 'hidden';
                 outputTableContainerBottom.style.overflowX = 'hidden';
                return;
            }

             // Add a header for match details
             const matchDetailsHeader = document.createElement('th');
             matchDetailsHeader.textContent = 'Possible Match Details';
             headerRow.appendChild(matchDetailsHeader);

            fuzzyMatches.forEach((match, index) => {
                const row = outputTableBody.insertRow();
                const rowNumberCell = row.insertCell();
                rowNumberCell.textContent = index + 1;

                const detailsCell = row.insertCell();
                let detailsHtml = `Match between: <strong>${match.file1}</strong> (Row ${match.row1Index}) and <strong>${match.file2}</strong> (Row ${match.row2Index})<br>Matched Columns: `;
                Object.keys(match.matchedColumns).forEach(colKey => {
                    detailsHtml += `[${colKey}: "${match.matchedColumns[colKey]}"] `;
                });
                detailsCell.innerHTML = detailsHtml;
                 detailsCell.classList.add('fuzzy-match-cell');
            });

            // Update scroll bars (might need adjustment for this display format)
             // For fuzzy matches displayed as a list, we only need vertical scrolling on the bottom container
             outputTableContainerTop.innerHTML = ''; // Clear top scroll area
             outputTableContainerTop.style.overflowX = 'hidden'; // Hide horizontal scroll on top
             outputTableContainerBottom.style.overflowX = 'hidden'; // Hide horizontal scroll on bottom
             outputTableContainerBottom.scrollTop = 0; // Start at the top
        }

        // Function to display exact/any matches
        function displayMatchingRows(matchedRecords) {
            outputTableBody.innerHTML = ''; // Clear previous output
            const headerRow = document.querySelector('#output-table thead tr');
            while (headerRow.cells.length > 1) { // Keep the row number header
                headerRow.deleteCell(1);
            }

            if (matchedRecords.length === 0) {
                const row = outputTableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = allColumnHeaders.length + 1; // Span across all possible columns + row number
                cell.textContent = 'No matching records found.';
                 outputTableContainerTop.style.overflowX = 'hidden'; // Hide horizontal scroll if no data
                 outputTableContainerBottom.style.overflowX = 'hidden'; // Hide horizontal scroll if no data
                return;
            }

            // Create headers dynamically based on all possible headers from all files
            allColumnHeaders.forEach(header => {
                filesData.forEach((fileData, fileIndex) => {
                    if (fileData && fileData.headers.includes(header)) {
                        const th = document.createElement('th');
                        th.textContent = `File ${fileIndex + 1} - ${header}`;
                        headerRow.appendChild(th);
                    } else if (fileData) {
                         // Add an empty header for files that don't have this column to maintain alignment
                        const th = document.createElement('th');
                        th.textContent = ''; // Empty header
                         headerRow.appendChild(th);
                    }
                });
            });


            matchedRecords.forEach((record, index) => {
                const row = outputTableBody.insertRow();
                const rowNumberCell = row.insertCell();
                rowNumberCell.textContent = index + 1; // Row number

                allColumnHeaders.forEach(header => {
                    filesData.forEach((fileData, fileIndex) => {
                         if (fileData && fileData.headers.includes(header)) {
                            const cell = row.insertCell();
                            const cellData = record[`File${fileIndex + 1} - ${header}`] || ''; // Use '' for undefined
                            cell.textContent = cellData;
                            // Add class based on file number for coloring
                            cell.classList.add(`file${fileIndex + 1}-cell`);
                         } else if (fileData) {
                             // Add an empty cell for files that don't have this column
                             const cell = row.insertCell();
                             cell.textContent = '';
                              // Add class based on file number for coloring
                             cell.classList.add(`file${fileIndex + 1}-cell`);
                         }
                    });
                });
            });

            // Ensure horizontal scrollbars appear if content overflows
            outputTableContainerTop.style.overflowX = 'auto';
            outputTableContainerBottom.style.overflowX = 'auto';
             outputTableContainerBottom.scrollTop = 0; // Start at the top
        }


        function updateDownloadOptions() {
            const downloadColumnsDiv = document.getElementById('download-options');
            const existingOptions = downloadColumnsDiv.querySelectorAll('.download-column-option');
            existingOptions.forEach(option => option.remove());

            allColumnHeaders.forEach(header => {
                filesData.forEach((fileData, fileIndex) => {
                    if (fileData && fileData.headers.includes(header)) {
                        const div = document.createElement('div');
                        div.classList.add('download-column-option');
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `download-col-file${fileIndex + 1}-${header.replace(/[^a-zA-Z0-9]/g, '')}`;
                        checkbox.value = `File ${fileIndex + 1} - ${header}`;
                        checkbox.checked = true; // Default to include all columns
                        const label = document.createElement('label');
                        label.setAttribute('for', `download-col-file${fileIndex + 1}-${header.replace(/[^a-zA-Z0-9]/g, '')}`);
                        label.textContent = `File ${fileIndex + 1} - ${header}`;
                        div.appendChild(checkbox);
                        div.appendChild(label);
                        downloadColumnsDiv.appendChild(div);
                    }
                });
            });
        }

        function selectAllDownloadColumns(isChecked) {
            const checkboxes = document.querySelectorAll('#download-options input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                if (checkbox.id !== 'select-all-columns' && checkbox.id !== 'unselect-all-columns') {
                    checkbox.checked = isChecked;
                }
            });
             // Uncheck the other special checkbox
            if(isChecked) {
                 document.getElementById('unselect-all-columns').checked = false;
            }
        }

         function unselectAllDownloadColumns(isChecked) {
            const checkboxes = document.querySelectorAll('#download-options input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                if (checkbox.id !== 'select-all-columns' && checkbox.id !== 'unselect-all-columns') {
                    checkbox.checked = !isChecked; // Unselect if this is checked
                }
            });
             // Uncheck the other special checkbox
            if(isChecked) {
                 document.getElementById('select-all-columns').checked = false;
            }
        }


        function downloadOutput() {
            const table = document.getElementById('output-table');
            let csvContent = [];
            const headers = [];
            const headerCells = table.querySelectorAll('thead th');
            const selectedDownloadColumns = Array.from(document.querySelectorAll('#download-options input[type="checkbox"]:checked'))
                                               .filter(cb => cb.id !== 'select-all-columns' && cb.id !== 'unselect-all-columns')
                                               .map(cb => cb.value);

            // Build the header row for the CSV based on selected download columns
             const csvHeaders = ['#']; // Start with row number
             headerCells.forEach((headerCell, index) => {
                 if (index > 0) { // Skip the row number header
                     const headerText = headerCell.textContent;
                     // Check if this header corresponds to a selected download column
                     if (selectedDownloadColumns.includes(headerText)) {
                          csvHeaders.push(`"${headerText.replace(/"/g, '""')}"`); // Enclose headers in quotes and escape existing quotes
                     }
                 }
             });
             csvContent.push(csvHeaders.join(','));


            table.querySelectorAll('tbody tr').forEach(row => {
                const rowData = [];
                const cells = row.querySelectorAll('td');
                const rowNumber = cells[0].textContent;
                 rowData.push(rowNumber); // Add row number

                // Build the data row for the CSV based on selected download columns
                let cellIndex = 1; // Start from the first data cell (after row number)
                allColumnHeaders.forEach(header => {
                     filesData.forEach((fileData, fileIndex) => {
                         if (fileData && fileData.headers.includes(header)) {
                              const headerText = `File ${fileIndex + 1} - ${header}`;
                              // Check if this header was selected for download
                              if (selectedDownloadColumns.includes(headerText)) {
                                   const cellValue = cells[cellIndex].textContent;
                                   rowData.push(`"${cellValue.replace(/"/g, '""')}"`); // Enclose data in quotes and escape existing quotes
                                   cellIndex++;
                              } else {
                                   cellIndex++; // Still need to advance cellIndex even if not included in download
                              }
                         } else if (fileData) {
                             // Account for empty cells for files that don't have this column
                              const headerText = `File ${fileIndex + 1} - ${header}`;
                              if (selectedDownloadColumns.includes(headerText)) {
                                  rowData.push(`""`); // Add empty cell for download
                                  cellIndex++;
                              } else {
                                   cellIndex++;
                              }
                         }
                     });
                 });


                csvContent.push(rowData.join(','));
            });

            const csvString = csvContent.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'matched_data.csv';
            link.click();
        }

        // Add event listener to the new fuzzy match button
        showFuzzyMatchesButton.onclick = function() {
            // Set a threshold for fuzzy matching (e.g., 0.8 means 80% similarity)
            // You might want to make this user-configurable in a more advanced version
            const fuzzyMatchThreshold = 0.8;
            const selectedColumns = getSelectedColumns();

            // Check if at least two files have selected columns and the same number of columns
            const validFilesWithSelectedCols = filesData.filter((file, index) => file !== null && selectedColumns[index].length > 0);
            if (validFilesWithSelectedCols.length < 2) {
                 alert('Please upload and select matching columns in at least two files for fuzzy matching.');
                 return;
            }
             const firstSelectedColCount = selectedColumns[filesData.indexOf(validFilesWithSelectedCols[0])].length;
             if (validFilesWithSelectedCols.some((file, index) => selectedColumns[filesData.indexOf(file)].length !== firstSelectedColCount)) {
                  alert('For fuzzy matching, please select the same number of columns in the files you want to compare.');
                 return;
             }


            loadingIndicator.style.display = 'block';
            setTimeout(() => {
                 const fuzzyMatches = findFuzzyMatchingPairs(filesData, selectedColumns, fuzzyMatchThreshold);
                displayFuzzyMatches(fuzzyMatches);
                loadingIndicator.style.display = 'none';
            }, 100);
        };


        // Sync scroll between top and bottom containers (for table view only)
        outputTableContainerBottom.addEventListener('scroll', () => {
            outputTableContainerTop.scrollLeft = outputTableContainerBottom.scrollLeft;
        });
        outputTableContainerTop.addEventListener('scroll', () => {
            outputTableContainerBottom.scrollLeft = outputTableContainerTop.scrollLeft;
        });

    </script>
</body>
</html>